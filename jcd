#! /usr/bin/env python
# -*- coding: UTF-8 -*- vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4

# The MIT License (MIT)
#
# Copyright (c) 2015 Nicolas Pillot
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the 'Software'),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

import sys
import errno
import shutil
import os.path
import sqlite3
import argparse

# applications specific exception
class JcdException(Exception):
    def __init__(self,*args,**kwargs):
        Exception.__init__(self,*args,**kwargs)

# yes/no choice
# from http://stackoverflow.com/a/4741730
def yn_choice(message, default='y'):
    choices = 'Y/n' if default.lower() in ('y', 'yes') else 'y/N'
    choice = raw_input("%s (%s) " % (message, choices))
    values = ('y', 'yes', '') if default == 'y' else ('y', 'yes')
    return choice.strip().lower() in values

# manages access to the application database
class AppDB:
    FileName = "app.db"
    SettingsTable = "settings"
    ApiCacheTable = "api_cache"

    def __init__(self, path):
        self._db_path = os.path.normpath("%s/%s" % (path,AppDB.FileName))
        print "Opening database [%s]" % self._db_path
        self._connection = sqlite3.connect(self._db_path)

    def createSettingsTable(self):
        print "Creating table [%s]" % AppDB.SettingsTable
        self._connection.execute(
            '''CREATE TABLE %s(
                    name TEXT PRIMARY KEY,
                    value -- no type, use affinity
            )''' % AppDB.SettingsTable)

    def createApiCacheTable(self):
        print "Creating table [%s]" % AppDB.ApiCacheTable
        self._connection.execute(
            '''CREATE TABLE %s(
                    url TEXT,
                    timestamp INTEGER,
                    json TEXT NOT NULL,
                    PRIMARY KEY(url,timestamp)
            )''' % AppDB.ApiCacheTable)

# initialize application data
class Initialize:
    def __init__(self, data_path, args):
        self._data_path = data_path
        self._args = args

    def _remove_folder(self):
        # ask the user for confirmation
        if not self._args.yes:
            if not yn_choice(
                    "Folder [%s] exists, delete it and its content ?"
                    % self._data_path, 'n'):
                raise JcdException("User refused to delete folder.")
        # actually delete the folder
        try:
            print "Removing folder [%s] and its content" % self._data_path
            shutil.rmtree(self._data_path)
        except OSError as e:
            # silently ignore "absent directory"
            if e.errno == errno.ENOENT:
                return
            # on other errors
            raise JcdException("Could not remove folder : %s" % e)

    def _create_folder(self):
        try:
            print "Creating folder [%s]" % self._data_path
            os.makedirs(self._data_path)
        except OSError as exception:
            # folder exists
            if exception.errno == errno.EEXIST:
                raise JcdException(
                    "Could not create folder [%s] "
                    "as it already exists. "
                    "Use --force to remove it "
                    "and its content." % self._data_path)
            # other system error
            raise

    def _create_tables(self):
        try:
            db = AppDB(self._data_path)
            db.createSettingsTable()
            db.createApiCacheTable()
        except sqlite3.Error as e:
            raise JcdException(
                "Database error (%s) : %s"
                % (e.__class__.__name__, e))

    def run(self):
        # remove folder if creation is forced
        if self._args.force:
            self._remove_folder()
        self._create_folder()
        # create tables in data db
        self._create_tables()

# main app
class App:
    def __init__(self, data_path):
        # store data path
        self._data_path = os.path.expanduser(data_path)
        # main parser
        top = argparse.ArgumentParser(
            description = 'Fetch and store JCDecaux API results',
        )
        subs = top.add_subparsers()

        # initialize command
        init = subs.add_parser(
            'initialize',
            help = 'create application files',
            description = 'Initialize application'
        )
        init.add_argument(
            '--force', '-f',
            action = 'store_true',
            help = 'overwrite existing files'
        )
        init.add_argument(
            '--yes', '-y',
            action = 'store_true',
            help = 'do not ask for confirmation before '
                'overwritingdo not ask for confirmation '
                'before overwriting'
        )
        init.set_defaults(func=self.initialize)
        # parse arguments
        self._args = top.parse_args()
        self._action = self._args.func
        # cleanup namespace
        del self._args.func

    def initialize(self):
        init = Initialize(self._data_path, self._args)
        init.run()

    def run(self):
        try:
            self._action()
        except JcdException as e:
            print e

# main
if __name__ == '__main__':
    app = App("~/.jcd")
    try:
        app.run()
    except KeyboardInterrupt:
        pass
